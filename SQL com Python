# Vamos colocar aqui formas diferentes de usar SQL com Python usando bibliotecas como pyodbc, Pandas e tkinter. 
# Iremos trabalhar o conceito CRUD (Create, Read, Update and Delete)

# Primeiro vamos instalar a biblioteca do pyodbc e o driver necessário para SQL através do pip install pyodbc e do site: http://www.ch-werner.de/sqliteodbc/
# Após isso iremos conferir se o driver está devidamente instalado através do código:

import pyodbc
print(pyodbc.drivers())
# Isso irá mostrar todos os drivers de bancos de dados disponíveis em seu computador

# Importante: Será necessário "abrir a conexão" do banco de dados, entretanto é muito importante que façamos o fechamento dessa conexão sempre que ela for aberta
# Também é importante que você não faça a execução de abertura de conexão uma segunda vez caso o seu código tenha tido sucesso na primeira. 

# Abrindo a conexão: Vamos estabelecer passando 3 dados: Driver, Servidor e o Banco de dados

import pyodbc

dados_conexao = ('Driver={SQLite3 ODBC Driver};Server=localhost;Database=chinook.db')
conexao = pyodbc.connect(dados_conexao)

# Caso o banco de dados tenha login e senha, será preciso inserir nos dados o UID= e o PWD=

# Agora vamos criar o "cursor"

cursor = conexao.cursor()

# Fechando a conexão: Bastando fechar a conexão e o cursor, sempre lembre de faze-lo quando terminar de editar o código, pois do contrário a conexão pode ser bloqueada e isso pode limitar a edição da base de dados. 

cursor.close()
conexao.close()

# Considerando que você ainda não fechou sua conexão, a partir de agora já podemos escrever nossos comandos de SQL
# dataframe = pd.read_sql('COMANDO_SQL', conexao) -> vai executar o comando SQL, gerando uma consulta e retornando a resposta dessa consulta para o dataframe
# Para pegar uma tabela inteira do nosso banco de dados, usaremos o comando SQL Select *: "SELECT * FROM BaseDeDados.Tabela"

cursor.execute("SELECT * FROM customers")

# Agora as informações da tabela do banco de dados foram armazenadas em um "Objeto", para visualizar os valores iremos criar outra variável e extrair esses dados

valores = cursor.fetchall()

# Para exibir alguns dos valores obtidos: 

print(valores[:10])

# Uma vez que já vimos como estabelecer e encerrar a conexão, vamos agora passar pelos 4 pontos do CRUD (Create, Read, Update and Delete)

# Create:
# Após estabelecer a conexão e criar o cursor, podemos fazer a execução de comandos SQL, entretanto mais um passo é necessário para que a mudança feita seja concluída
# Outra dica de execução de comandos SQL é utilizar aspas triplas para mandar as informações em um bloco de texto de forma "mais organizada"
# Neste banco de dados de uma loja de discos vamos inserir o album Death Magnetic da banda Metallica na base de dados. Sabemos que a banda possui o ID de número 50

cursor.execute("""
INSERT INTO Albums (Title, ArtistID)
VALUES
('Death Magnetic', 50)
"""")

# Para concluir este terceiro passo é necessário utilizar o método .commit() em nosso cursor

cursor.commit()

# E o passo final é o fechamento do cursor e a conexão

cursor.close()
conexao.close()

# Agora podemos acessar o banco de dados através do DB Browser e ver que a alteração foi feita com sucesso.

# Read: 
# Agora vamos aprender a utilizar o Pandas para ler e importar informações do SQL.
# Relembrando que sempre iremos abrir a conexão, entretanto iremos importar duas bibliotecas e uma delas muda a forma como iremos estabelecer essa conexão

import pandas as pd
import sqlite3

conexao = sqlite3.connect("chinook.db")

# E iremos selecionar uma tabela dentro do banco de dados utilizando o pandas

tabela_clientes = pd.read_sql("SELECT * FROM customers", conexao)
# Já é possível ver o resultado utilizando o método display()
# A esta altura já é possível inclusive encerrar a conexão feita com o banco de dados, sendo que as informações atribuidas na variável continuarão lá

conexao.close()

# Agora é possível trabalhar no banco de dados utilizando o Pandas

# Update: 

# O processo para abertura de conexão é o mesmo com a biblioteca pyodbc

import pyodbc

dados_conexao = ('Driver={SQLite3 ODBC Driver};Server=localhost;Database=chinook.db')
conexao = pyodbc.connect(dados_conexao)

cursor = conexao.cursor()

# Agora iremos fazer a "atualização" da informação no banco de dados através do comando SQL
# A alteração será o e-mail de um cliente na tabela de clientes do nosso banco de dados, o cliente 1 possui o e-mail luisg@embraer.com.br, iremos mudar para luisgoncalves@embraer.com.br
# Junto com o código também iremos fazer a conclusão da alteração e o fechamento da conexão/cursor

cursor.execute('''
UPDATE customers SET Email="luisgoncalves@embraer.com.br" WHERE="luisg@embraer.com.br"
''')

cursor.commit()
cursor.close()
conexao.close()

# Agora podemos atualizar nosso banco de dados e verificar que o E-mail do cliente foi alterado com sucesso

# Delete:
# Para concluir o CRUD, iremos apagar um dado do nosso banco de dados (Delete)
# Devemos ter mais cuidado quando tentamos fazer isso pois é relativamente fácil apagar uma tabela inteira quando estamos realizando este processo.
# Considerando que o processo de abertura e fechamento da conexão é o mesmo, iremos partir do comando cursor.execute()
# O AlbumID em questão é o número 84, e o ArtistID é 86. Roda De Funk de Funk Como Le Gusta

cursor.execute('''
DELETE FROM albums WHERE AlbumId=84
''')

# Vale ressaltar que este processo irá apagar também qualquer relação que este dado em específico possua com qualquer outra informação do seu banco de dados, como compras por parte de clientes. Uma vez que esta informação "não existe mais" no banco de dados.

# Agora que já passamos pelos 4 passos básicos, vamos exercitar de forma mais complexa.
# Para isso vamos utilizar a seguinte base de dados: https://drive.google.com/file/d/1f6whQ9Obhe0t2IarRfWLk0kjpSv1AG14/view?usp=share_link

# Vamos fazer um relatório de análise apenas da unidade de San Francisco para enteder:
# Qual a evolução do salário médio ao longo dos anos
# Quantos funcionários tivemos ao longo dos anos
# Qual a evolução do total gasto com salários ao longo do ano

# Então vamos começar importando a base de dados:

import pandas as pd
import sqlite3

conexao = sqlite3.connect('salarios.sqlite')

tabela_salarios = pd.read_sql('SELECT * FROM Salaries', conexao)
conexao.close()

# Agora que a nossa tabela de salários foi criada com a variável tabela_salarios não precisamos mais manter a conexão aberta, sendo assim podemos partir para a análise:
# Vamos primeiro garantir que iremos trabalhar apenas com os funcionários da unidade de San Francisco

tabela_salarios = tabela_salarios.loc[tabela_salarios["Agency"]=="San Francisco", :]

# 1. Evolução de salário:
# Primeiro vamos separar os pagamentos por ano:

tabela_sm = tabela_salarios.groupby("Year").mean()
display(tabela_sm[["TotalPay", "TotalPayBenefits"]])

# 2. Quantidade de funcionários:

tabela_qtde = tabela_salarios.groupby("Year").count()
tabela_qtde = tabela_qtde[["Id"]]
tabela_qtde = tabela_qtde.rename(columns={"Id": "Qtde"})
display(tabela_qtde)

# 3. Evolução de gastos com salários:
# Uma vez que estes valores são muito altos, vamos criar uma função que formata o valor para mostrar um resultado final mais adequado
def formatar(valor):
    return 'R${:,.2f}'.format(valor)

# Agora vamos fazer o agrupamento e a formatação dos valores aplicando a função
tabela_total = tabela_salarios.groupby("Year").sum()
tabela_total = tabela_total[["TotalPay", "TotalPayBenefits"]]
tabela_total["TotalPay"] = tabela_total["TotalPay"].apply(formatar)
tabela_total["TotalPayBenefits"] = tabela_total["TotalPayBenefits"].apply(formatar)
display(tabela_total)










